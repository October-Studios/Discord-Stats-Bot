'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs-promise'));
var path = _interopDefault(require('path'));
var uuid = _interopDefault(require('uuid'));
var _request = _interopDefault(require('request'));
var promisify = _interopDefault(require('es6-promisify'));
var http = require('http');
var tarStream = require('tar-stream');
var zlib = require('zlib');
var del = _interopDefault(require('del'));
var child_process = require('child_process');
var lodash = require('lodash');
var ms = _interopDefault(require('ms'));
var express = _interopDefault(require('express'));

var babelHelpers = {};

babelHelpers.asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            return step("next", value);
          }, function (err) {
            return step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

babelHelpers.classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

babelHelpers.createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

babelHelpers.slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

babelHelpers;

const request = promisify(_request);

Object.getOwnPropertyNames(_request).forEach(k => {
	if (typeof _request[k] === "function") {
		request[k] = _request[k].bind(_request);
	}
});

let fetch = (() => {
	var ref = babelHelpers.asyncToGenerator(function* (cwd) {
		let data;

		try {
			data = yield fs.readFile(path.resolve(cwd, ".session"), "utf8");
		} catch (e) {
			if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
		}

		try {
			data = JSON.parse(data);
		} catch (e) {
			e;
		}

		return data ? new Session(data) : null;
	});
	return function fetch(_x3) {
		return ref.apply(this, arguments);
	};
})();

let authenticate = (() => {
	var ref = babelHelpers.asyncToGenerator(function* (user, pass) {
		if (typeof user !== "string" || !user) {
			throw new Error("Missing username.");
		}

		if (typeof pass !== "string") {
			throw new Error("Missing password.");
		}

		var _ref4 = yield request({
			method: "POST",
			url: auth_url + "/authenticate",
			json: true,
			body: {
				agent: { name: "Minecraft", version: 1 },
				username: user,
				password: pass,
				clientToken: uuid.v4()
			}
		});

		var _ref5 = babelHelpers.slicedToArray(_ref4, 2);

		let resp = _ref5[0];
		let body = _ref5[1];


		if (resp.statusCode !== 200) {
			throw {
				error: true,
				status: resp.statusCode,
				type: body.error,
				message: body.errorMessage
			};
		}

		return new Session(body);
	});
	return function authenticate(_x4, _x5) {
		return ref.apply(this, arguments);
	};
})();

const auth_url = "https://authserver.mojang.com";

let Session = function () {
	function Session(_ref) {
		let accessToken = _ref.accessToken;
		let clientToken = _ref.clientToken;
		let selectedProfile = _ref.selectedProfile;
		let profile = _ref.profile;
		let worldVersion = _ref.worldVersion;
		babelHelpers.classCallCheck(this, Session);

		this.accessToken = accessToken;
		this.clientToken = clientToken;
		this.profile = profile || selectedProfile;
		this.worldVersion = worldVersion;
	}

	babelHelpers.createClass(Session, [{
		key: "toJSON",
		value: function toJSON() {
			let keys = Object.getOwnPropertyNames(this);
			let obj = {};

			for (let i = 0; i < keys.length; i++) {
				obj[keys[i]] = this[keys[i]];
			}

			return obj;
		}
	}, {
		key: "save",
		value: (() => {
			var ref = babelHelpers.asyncToGenerator(function* (cwd) {
				yield fs.writeFile(path.resolve(cwd, ".session"), JSON.stringify(this.toJSON(), null, 2));
			});

			function save(_x) {
				return ref.apply(this, arguments);
			}

			return save;
		})()
	}, {
		key: "destroy",
		value: (() => {
			var ref = babelHelpers.asyncToGenerator(function* (cwd) {
				yield fs.unlink(path.resolve(cwd, ".session"));
			});

			function destroy(_x2) {
				return ref.apply(this, arguments);
			}

			return destroy;
		})()
	}, {
		key: "isValid",
		value: (() => {
			var ref = babelHelpers.asyncToGenerator(function* () {
				var _ref2 = yield request({
					method: "POST",
					url: auth_url + "/validate",
					json: true,
					body: {
						accessToken: this.accessToken,
						clientToken: this.clientToken
					}
				});

				var _ref3 = babelHelpers.slicedToArray(_ref2, 1);

				let resp = _ref3[0];


				return resp.statusCode === 204;
			});

			function isValid() {
				return ref.apply(this, arguments);
			}

			return isValid;
		})()
	}]);
	return Session;
}();

let init = (() => {
	var ref = babelHelpers.asyncToGenerator(function* (cwd, user, pass) {
		let sess = yield fetch(cwd);

		if (!sess || !(yield sess.isValid())) {
			if (sess) yield sess.destroy(cwd);
			sess = yield authenticate(user, pass);
			yield sess.save(cwd);
		}

		return sess;
	});
	return function init(_x6, _x7, _x8) {
		return ref.apply(this, arguments);
	};
})();

let getUrl = (() => {
	var ref = babelHelpers.asyncToGenerator(function* (id, sess) {
		if (!id) {
			throw new Error("Missing world id.");
		}

		let jar = request.jar();
		jar.setCookie(request.cookie(`sid=token:${ sess.accessToken }:${ sess.profile.id }`), realms_url);
		jar.setCookie(request.cookie(`user=${ sess.profile.name }`), realms_url);
		jar.setCookie(request.cookie(`version=1.9.2`), realms_url);

		var _ref = yield request({
			jar, url: realms_url + "/worlds/" + id + "/backups/download"
		});

		var _ref2 = babelHelpers.slicedToArray(_ref, 2);

		let resp = _ref2[0];
		let body = _ref2[1];


		if (resp.statusCode === 401 || resp.statusCode === 403) {
			throw new Error("Invalid session.");
		}

		if (resp.statusCode !== 200) {
			throw new Error(`Unknown Realms API error [Status ${ resp.statusCode }]`);
		}

		return body;
	});
	return function getUrl(_x, _x2) {
		return ref.apply(this, arguments);
	};
})();

const realms_url = "https://mcoapi.minecraft.net";

function untar(cwd) {
	let untar = tarStream.extract();

	untar.on("entry", (() => {
		var ref = babelHelpers.asyncToGenerator(function* (header, content, next) {
			try {
				let plen = path.normalize(header.name).split(".").length;
				let file = path.resolve(cwd, header.name);

				// delete root directories
				if (plen === 1) yield del(file, { force: true });

				// make new file/directory
				if (header.type === "directory") {
					yield fs.mkdir(file);
					content.resume();
				} else if (header.type === "file") {
					let out = fs.createWriteStream(file);
					yield new Promise(function (resolve, reject) {
						out.on("finish", resolve);
						out.on("error", reject);
						content.pipe(out);
					});
				} else {
					content.resume();
				}

				next();
			} catch (e) {
				next(e);
			}
		});
		return function (_x3, _x4, _x5) {
			return ref.apply(this, arguments);
		};
	})());

	return untar;
}

var download = (() => {
	var ref = babelHelpers.asyncToGenerator(function* (sid, sess, cwd) {
		let url = yield getUrl(sid, sess);
		let req = http.get(url);
		let ver;

		yield new Promise(function (resolve, reject) {
			req.on("response", function (res) {
				ver = res.headers["x-amz-version-id"];
				if (ver && ver === sess.worldVersion) {
					req.abort();
					return resolve();
				}

				res.on("error", reject).pipe(zlib.createGunzip()).on("error", reject).pipe(untar(cwd)).on("error", reject).on("finish", resolve);
			});

			req.on("error", reject);
		});

		sess.worldVersion = ver;
		yield sess.save(cwd);
	});

	function download(_x6, _x7, _x8) {
		return ref.apply(this, arguments);
	}

	return download;
})();

var configsrc = "worlds['My World'] = <%= JSON.stringify(world) %>\n\noutputdir = <%= JSON.stringify(output) %>\n\nrendermode = \"lighting\"\n\nrenders[\"render1\"] = {\n        'world': 'My World',\n        'title': 'A regular render'\n}\n";

const configtpl = lodash.template(configsrc);

var spawn$1 = babelHelpers.asyncToGenerator(function* () {
	let cwd = arguments.length <= 0 || arguments[0] === undefined ? "." : arguments[0];
	let bin = arguments[1];
	let _ref = arguments[2];
	let config = _ref.config;
	var _ref$mapdir = _ref.mapdir;
	let mapdir = _ref$mapdir === undefined ? "./map" : _ref$mapdir;

	if (typeof bin !== "string" || !bin) {
		throw new Error("Missing overviewer binary path.");
	}

	cwd = path.resolve(cwd);

	if (typeof config !== "string" || !config) {
		config = "overviewer_config.py";
		let cfile = path.join(cwd, "overviewer_config.py");
		try {
			yield fs.stat(cfile);
		} catch (e) {
			if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
			yield fs.writeFile(cfile, configtpl({
				world: "./world",
				output: path.relative(cwd, path.resolve(cwd, mapdir))
			}));
		}
	}

	let proc = child_process.spawn(bin, ["--config=" + config], {
		cwd, stdio: "inherit"
	});

	yield new Promise(function (resolve, reject) {
		proc.on("close", function (code) {
			return code ? reject(new Error("Overviewer failed.")) : resolve();
		});
	});
});

let render = (() => {
	var ref = babelHelpers.asyncToGenerator(function* () {
		let cwd = arguments.length <= 0 || arguments[0] === undefined ? "." : arguments[0];
		let _ref = arguments[1];
		let username = _ref.username;
		let password = _ref.password;
		let id = _ref.id;
		let bin = _ref.overviewer;
		let config = _ref.overviewerConfig;
		let mapdir = _ref.mapdir;

		let sess = yield init(cwd, username, password);
		yield download(id, sess, cwd);
		yield spawn$1(cwd, bin, { config, mapdir });
	});
	return function render() {
		return ref.apply(this, arguments);
	};
})();

let autorender = (() => {
	var ref = babelHelpers.asyncToGenerator(function* (cwd, opts) {
		yield render(cwd, opts);

		let rendering = false;
		let interval = opts.interval;
		let onerror = opts.onerror;
		let onstart = opts.onstart;
		let onfinish = opts.onfinish;

		interval = ms(typeof interval === "string" ? interval : "24h");

		let int = setInterval(babelHelpers.asyncToGenerator(function* () {
			if (rendering) return;

			try {
				rendering = true;
				if (typeof onstart === "function") onstart();
				yield render(cwd, opts);
				if (typeof onfinish === "function") onfinish();
			} catch (e) {
				if (typeof onerror === "function") onerror(e);
			} finally {
				rendering = false;
			}
		}), Math.max(5 * 60 * 1000, interval));

		return function () {
			clearInterval(int);
		};
	});
	return function autorender(_x2, _x3) {
		return ref.apply(this, arguments);
	};
})();

function createApp() {
	let cwd = arguments.length <= 0 || arguments[0] === undefined ? "." : arguments[0];
	let _ref = arguments[1];
	var _ref$mapdir = _ref.mapdir;
	let mapdir = _ref$mapdir === undefined ? "./map" : _ref$mapdir;

	let app = express();
	app.set("x-powered-by", false);
	app.use(express.static(path.resolve(cwd, mapdir)));
	return app;
}

exports.render = render;
exports.autorender = autorender;
exports.createServer = createApp;